//
//  main.cpp
//  11726 2×n 타일링
//
//  Created by Sun on 2023/11/13.
//

#include <iostream>

using namespace std;

int main(int argc, const char * argv[]) {

    int n;
    int d[1001];

    cin >> n;
    for (int i = 0; i <= n; i++) {
        if (i == 0 || i == 1)
            d[i] = 1;
        else
            d[i] = (d[i-1] + d[i-2]);
    }

    cout << d[n];

    return 0;
}

// dp로 구현
// n = 2,3,4... 정도의 케이스만 그려보면 쉽게 규칙을 구할 수 있고 다음과 같은 점화식이 도출됨
// d[i] = d[i-1] + d[i-2] (피보나치 수열)
// n=(i-1)인 case들의 오른쪽에 2x1 타일 1개 붙이기 + n=(i-2)인 case들의 오른쪽에 1x2 타일 2개 붙이기

// 조합으로 구현 -> x
// 2xn에서 n=9인 케이스라면,, 각 블록의 개수로 경우의 수를 구하면 다음과 같다. (x왼쪽은 가로길이)
// 2x4, 1x1 -> 5! / 4! = 5
// 2x3, 1x3 -> 6! / (3! * 3!) = 20
// ...
// 2x0, 1x9 -> 9! / 9! = 1
// 근데 이렇게 구현하면 .. 런타임 에러 (IntegerOverflow)가 난다!

// int factorial(int n) {
//     if (n <= 1)    return 1;
//     return n * factorial(n-1);
// }

// int main(int argc, const char * argv[]) {
//     ...
//     int ans = 0;
//     for (int i = 0; i <= n/2; i++) {
//         int j = n - 2 * i;
//         ans += factorial(i+j) / (factorial(i) * factorial(j));
//     }
//     ...
// }

// 그 이유는.. dp로 구한 정답 코드에서 구한 답이 실제 답이 아니기 때문!이라고 이해했다
// factorial 코드로는 한번에 정답을 딱 구하는 건데 그 숫자가 크면 답이 상상 이상으로 크게 나온다. ㅇㅅㅇ
// 그래서 dp로 구하는 답은 매 단계?마다의 값을 10007로 나눈 나머지들이 실제 경우의 수를 대표하는 값이 되어
// 가짜 답(이지만 진짜 답에 대응되는 답..)을 구해내는 것이기 때문에, 한번에 경우의 수를 구하려는 두 번째 코드로는 답을 구해낼 수 없을 것..
// 물론 n=1000일 때의 경우의 수인
// 70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501
// 을 변수 ans가 담을 수 있다면 마지막에 %10007을 해주는 것만으로도 같은 답을 구할 수 있겠다만
// 파이썬처럼 int 자료형이라는 객체 내부에서 정수를 배열로 변환해 저장함으로써 무한한 크기의 정수를 표현(정수 오버플로 발생x)할 수 있지 않는 한...
